(()=>{"use strict";const e=express,s=mongoose,t=cors,n=dotenv,a=jsonwebtoken,o=bcryptjs,i=s.Schema({name:{type:String,required:!0},email:{type:String,required:!0},password:{type:String,required:!0},about:{type:String},tags:{type:[String]},joinedOn:{type:Date,default:Date.now}}),d=s.model("User",i),r=(e,s,t)=>{try{const s=e.headers.authorization.split(" ")[1];let n=a.verify(s,process.env.JWT_SECRET);e.userId=n?.id,t()}catch(e){console.log(e)}},u=e.Router();u.post("/signup",(async(e,s)=>{const{name:t,email:n,password:i}=e.body;try{if(await d.findOne({email:n}))return s.status(404).json({message:"An account with this email already exists, please log in"});const e=await o.hash(i,12),r=await d.create({name:t,email:n,password:e}),u=a.sign({email:r.email,id:r._id},process.env.JWT_SECRET,{expiresIn:"1h"});s.status(200).json({result:r,token:u})}catch(e){s.status(500).json("Something went wrong...")}})),u.post("/login",(async(e,s)=>{const{email:t,password:n}=e.body;try{const e=await d.findOne({email:t});if(!e)return s.status(404).json({message:"Account with this email does not exist! Please sign up first."});if(!await o.compare(n,e.password))return s.status(400).json({message:"Invalid credentials!"});const i=a.sign({email:e.email,id:e._id},process.env.JWT_SECRET,{expiresIn:"1h"});s.status(200).json({result:e,token:i})}catch(e){s.status(500).json("Something went wrong...")}})),u.get("/getAllUsers",(async(e,s)=>{try{const e=await d.find(),t=[];e.forEach((e=>{t.push({_id:e._id,name:e.name,about:e.about,tags:e.tags,joinedOn:e.joinedOn})})),s.status(200).json(t)}catch(e){s.status(404).json({message:e.message})}})),u.patch("/update/:id",r,(async(e,t)=>{const{id:n}=e.params,{name:a,about:o,tags:i}=e.body;if(!s.Types.ObjectId.isValid(n))return t.status(404).send("question unavailable...");try{const e=await d.findByIdAndUpdate(n,{$set:{name:a,about:o,tags:i}},{new:!0});t.status(200).json(e)}catch(e){t.status(405).json({message:e.message})}}));const c=u,l=s.Schema({questionTitle:{type:String,required:"Question must have a title"},questionBody:{type:String,required:"Question must have a body"},questionTags:{type:[String],required:"Question must have a tags"},noOfAnswers:{type:Number,default:0},upVote:{type:[String],default:[]},downVote:{type:[String],default:[]},userPosted:{type:String,required:"Question must have an author"},userId:{type:String},askedOn:{type:Date,default:Date.now},answer:[{answerBody:String,userAnswered:String,userId:String,answeredOn:{type:Date,default:Date.now}}]}),p=s.model("Question",l),y=e.Router();y.post("/Ask",r,(async(e,s)=>{const t=e.body,n=new p(t);try{await n.save(),s.status(200).json("Posted a question successfully")}catch(e){console.log(e),s.status(409).json("Couldn't post a new question")}})),y.get("/get",(async(e,s)=>{try{const e=await p.find();s.status(200).json(e)}catch(e){s.status(404).json({message:e.message})}})),y.delete("/delete/:id",r,(async(e,t)=>{const{id:n}=e.params;if(!s.Types.ObjectId.isValid(n))return t.status(404).send("Question unavailable...");try{await p.findByIdAndRemove(n),t.status(200).json({message:"Successfully deleted..."})}catch(e){t.status(404).json({message:e.message})}})),y.patch("/vote/:id",r,(async(e,t)=>{const{id:n}=e.params,{value:a,userId:o}=e.body;if(!s.Types.ObjectId.isValid(n))return t.status(404).send("question unavailable...");try{const e=await p.findById(n),s=e.upVote.findIndex((e=>e===String(o))),i=e.downVote.findIndex((e=>e===String(o)));"upVote"===a?(-1!==i&&(e.downVote=e.downVote.filter((e=>e!==String(o)))),-1===s?e.upVote.push(o):e.upVote=e.upVote.filter((e=>e!==String(o)))):"downVote"===a&&(-1!==s&&(e.upVote=e.upVote.filter((e=>e!==String(o)))),-1===i?e.downVote.push(o):e.downVote=e.downVote.filter((e=>e!==String(o)))),await p.findByIdAndUpdate(n,e),t.status(200).json({message:"voted successfully..."})}catch(e){t.status(404).json({message:"id not found"})}}));const g=y,w=async(e,s)=>{try{await p.findByIdAndUpdate(e,{$set:{noOfAnswers:s}})}catch(e){console.log(e)}},m=e.Router();m.patch("/post/:id",r,(async(e,t)=>{const{id:n}=e.params,{noOfAnswers:a,answerBody:o,userAnswered:i,userId:d}=e.body;if(!s.Types.ObjectId.isValid(n))return t.status(404).send("question unavailable...");w(n,a);try{const e=await p.findByIdAndUpdate(n,{$addToSet:{answer:[{answerBody:o,userAnswered:i,userId:d}]}});t.status(200).json(e)}catch(e){t.status(400).json("error in updating")}})),m.patch("/delete/:id",r,(async(e,t)=>{const{id:n}=e.params,{answerId:a,noOfAnswers:o}=e.body;if(!s.Types.ObjectId.isValid(n))return t.status(404).send("Question unavailable...");if(!s.Types.ObjectId.isValid(a))return t.status(404).send("Answer unavailable...");w(n,o);try{await p.updateOne({_id:n},{$pull:{answer:{_id:a}}}),t.status(200).json({message:"Successfully deleted..."})}catch(e){t.status(405).json(e)}}));const f=m,h=e();n.config(),h.use(e.json({limit:"30mb",extended:!0})),h.use(e.urlencoded({limit:"30mb",extended:!0})),h.use(t()),h.get("/",((e,s)=>{s.send("This is a stack overflow clone API")})),h.use("/user",c),h.use("/questions",g),h.use("/answer",f);const j=process.env.PORT||5e3,S=process.env.CONNECTION_URL;s.connect(S,{useNewUrlParser:!0,useUnifiedTopology:!0}).then((()=>h.listen(j,(()=>{console.log(`server running on port ${j}`)})))).catch((e=>console.log(e.message)))})();